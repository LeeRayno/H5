# HTTP

## 浏览器（HTTP）缓存机制

[原文链接](https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/)

### 缓存过程分析

浏览器与服务器通信方式为应答模式，即 **浏览器发起请求 - 服务器响应该请求**。 浏览器 **第一次** 向服务器发送请求后，会根据响应头缓存标识来将请求结果和缓存标识存入到 **浏览器缓存** 中

- 浏览器每次发送请求，都会先在 **浏览器缓存** 中查找该请求结果和缓存标识（浏览器 —> 浏览器缓存 —> 服务器）
- 浏览器每次拿到相应结果都会将该结果和缓存标识存入浏览器缓存中

HTTP 缓存分为强制缓存和协商缓存

### 强制缓存

> 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，主要分三种情况

1. 存在该缓存结果和缓存标识，且缓存结果有效，则强制缓存生效。直接返回该结果(不发送请求)
2. 不存在该缓存结果和缓存标识，则强制缓存失效。则直接向服务器发送请求(跟第一次发送请求一致)
3. 存在该缓存结果和缓存标识，但该结果已经失效，则使用协商缓存

> 控制强制缓存的字段 是 `Cache-Control`和 `Expires`, 区别在于 `Cache-Control` 是 `HTTP/1.1` 的产物， `Expries` 是 `HTTP/1.0` 的产物， 当两者同时存在的话，`Catch-Control`的优先级大于`Expires`，在某些不支持`HTTP/1.1`的环境下，`Expires`就发挥作用，现阶段他的存在只是一种兼容性的写法

#### Cache-Control

> Cache-Control 主要取值如下：

- public: 所有内容都会被缓存，(客户端和代理服务器都可以缓存)
- pravite: 所有内容只有客户端可以缓存，`Catch-Control`的默认值
- no-catch: 客户端缓存，需要通过协商缓存来验证是否缓存
- no-store: 所有内容都不会被缓存，即不使用强制缓存，也不实用协商缓存
- max-age=300: 缓存内容将会在`300`秒后失效

#### Exipres

> 设置过期时间，如：`expires: Sat, 21 Apr 2018 06:06:15 GMT`

### 协商缓存

> 协商缓存是在强制缓存失效后，浏览器携带缓存标识向服务器发送请求，服务器根据缓存标识决定是否使用缓存的过程，主要以下两种情况：

#### 304(协商缓存生效)

浏览器携带缓存标识发起 HTTP 请求，服务器查找该资源无更新，返回 304，向浏览器缓存要结果

#### 200(协商缓存失效)

浏览器携带缓存标识发起 HTTP 请求，服务器查找该资源已更新，返回 200，重新返回资源给浏览器，并存入浏览器缓存中

协商缓存的控制字段为: `Etag/If-None-Matched` 和 `Last-Modified/If-Modified-Since`，优先级前者大于后者

#### Etag/If-None-Matched

> `Etag(Response Headers)` 是上一次加载资源时，服务器返回当前资源的唯一标识，由服务器生成 ,如： `Etag: b7d8eafd0a3f63f71de7534d02295a3d`。 `If-None-Mathced(Request Headers)`是客户端再次发送请求时，拿上一次的`Etag`作为值，如： `If-None-Match: b7d8eafd0a3f63f71de7534d02295a3d`。发送到服务器，服务器接收到`If-None-Matched`的值和`Etag`比较，如果相等代表资源未更新，命中协商缓存，返回状态码 `304`；不相等代表资源已更新，返回状态码 `200`

#### Last-Modified/If-Modified-Since

> `Last-Modified(Response Headers)`是资源最后一次更新时间，`If-Modified-Since`是客户端再次发送请求时，把上次的`Last-Modified`的时间作为值发送到服务器，如果服务器现在的时间大于`If-Modified-Since`的值，说明资源已更新，重新返回资源，返回状态码 `200`, 否则资源未更新，返回状态码`304`

### 如何清除缓存

> 实际工作中很多场景都需要避免浏览器缓存

1. 浏览器隐私模式
2. 设置请求头：`Cathce-Control: no-cache, no-store, must-revalidate`
3. 给资源加版本号,如： `<javascript src="../js/util.js?v=1.1.1"></javascript>`
4. meta 标签, 如： `<meta http-equiv="Catche-Control" content="no-catche, no-store, must-revalidate" />`

### 用户行为对浏览器缓存的控制

1. F5 刷新，浏览器会设置 `Cathce-Control: max-age=0`，跳过强制缓存判断，会进行协商缓存判断
2. Ctrl + F5 强制刷新，跳过强制缓存和协商缓存，直接从服务器获取资源

## HTTP 状态码

### 2xx 成功

- 200 OK, 表示客户端发来的请求在服务端被正确处理
- 204 Content, 标识请求成功，但响应报文不含实体主题部分
- 206 Partial Content, 进行范围请求

### 3xx 重定向

- 301 Moved Permanently, 永久重定向，表示资源已被分配了新的 URL
- 302 Found, 临时重定向，表示资源被临时分配了新的 URL
- 303 See Other, 表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 Not Modified, 协商缓存
- 307 Temporay Redirect 临时重定向，和 302 一样

### 4xx 客户端错误

- 400 Bad Request 请求报文存在语法错误
- 401 UnAuthorized, 未认证，没有权限
- 403 Forbidden, 表示拒绝访问
- 404 Not Found, 资源不存在

### 5xx 服务端错误

- 500 Internal Server Error, 服务端错误
- 503 Service Unavaliable, 表示服务器暂时处于超负载或停机维护，无法处理请求

## TCP/IP 三次握手

**目的：为了准确无误的将数据送达到目标，TCP 采用了三次握手策略。**

> TCP 协议将数据包发送出去之后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志 (flag) - SYN (synchronize) 和 ACK (acknowledgement)。

1. 发送端首先发送一个带 SYN 标志的数据包给对方。
2. 接收端接收到数据后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。
3. 最后，发送端在回传一个带有 ACK 标志的数据包，代表握手结束。

若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。

## 七层协议

![TCP/IP](https://tva1.sinaimg.cn/large/007S8ZIlly1ggpfwr4p35j30fs0ea4g2.jpg)

- 物理层（网络电缆/ wifi）
- 数据链路层（以太网）
- 网络层（IPv4）
- 传输层（TCP）
- 会话层（SSL）
- 表示层
- 应用层（HTTP）

## HTTP2.0

### HTTP1.x 有哪些问题、缺陷

[原文](https://juejin.im/post/5c0ce870f265da61171c8c66) [原文](https://github.com/ljianshu/Blog/issues/57)

- 线头阻塞：TCP 连接上只能发送一个请求，前面的请求未完成前，后面的请求都得排队
- 多个 TCP 连接：1.1 版本请求并发依赖于多个 TCP 连接，建立 TCP 连接成本很高，还会存在慢启动问题
  [![TCP](https://camo.githubusercontent.com/f890478d84809b5ba4744818ab707723ca730ad0/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f322f32372f313639326661323965343133343866373f773d37343526683d33353826663d706e6726733d3834373230)](https://camo.githubusercontent.com/f890478d84809b5ba4744818ab707723ca730ad0/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f322f32372f313639326661323965343133343866373f773d37343526683d33353826663d706e6726733d3834373230)
- 头部冗余：HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。
- 客户端需要主动发送

### HTTP2.0 有哪些改变

- 二进制分侦层：HTTP2.0性能提升的核心就在于二进制分侦层。HTTP2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。
  - [![img](https://user-gold-cdn.xitu.io/2018/12/9/16792b2d88c55af5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)](https://user-gold-cdn.xitu.io/2018/12/9/16792b2d88c55af5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- 多路复用：HTTP2 让所有的请求都在一个TCP连接上完成，看1.x缺陷 上图
- 头部压缩：HTTP2 采用 HPACK 压缩格式来压缩头部，头部压缩需要在浏览器和服务端之间（常见的字段在第二次及之后只需传一个索引就可以，只需一个字节大小）
  - 维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合[完整的表](https://httpwg.org/specs/rfc7541.html#static.table.definition)
  - 维护一份相同的动态字典，可以动态的添加内容
  - 通过静态 Huffman 编码对传输的首部字段进行编码
- 服务端推送：务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。

## HTTPS

> HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。即 `HTTPS` = `HTTP` + `TLS/SSL` [原文](https://github.com/ljianshu/Blog/issues/50) SSL属于会话层

### 为什么需要 HTTPS

在 HTTP 协议中可能存在信息窃取或身份伪装等安全问题，使用 HTTPS 通信机制可以有效防止这些问题。HTTP 存在如下问题：

- HTTP报文明文通信，容易被窃取
- 容易遭篡改
- 容易遭遇伪装

### 对称加密

采用相同的`对称密钥`加解密

- 假如：对称密钥为`2`, 字符串为`12345`;  
- 加密过程为每个字符加`2`之后为`34567`;
- 解密过程为每个字符减`2`之后为`12345`

### 非对称加密

非对称加密有`公钥`和`私钥`，一般`公钥`由服务端发送给`客户端`,`私钥`放在服务端

- `公钥`用来加密`对称密钥`
- `私钥`用来解密`对称密钥`

### HTTPS 加密交互过程

HTTPS 采用 `对称加密`和`非对称加密`组合的方式来进行加密。  
**`对称加密`的作用是用来加解密`HTTP报文`的。**  
**`非对称加密`的作用是用来加解密`对称密钥`的**

过程大概如下：

1. 准备阶段：服务端需要先向`CA`机构申请相关`数字签名`,`数字证书`等证书
2. 客户端访问`https://www.baidu.com`,服务端返回`公钥`给客户端
3. 客户端验证`公钥`是否合法，如不合法会给出警告⚠️；如合法会随机生成一个`对称密钥`,并用`公钥`加密这个`对称密钥`,加密之后发给服务端
4. 服务端接收后，用`私钥`解密。获取到`对称密钥`。至此，客户端服务端都拥有`对称密钥`
5. 服务端用`对称密钥`加密`HTTP报文 A`并发送给客户端
6. 客户端用`对称密钥`解密。得到`HTPP报文 A`
7. 客户端再次发起`HTTPS`请求，用`对称密钥`加密`HTTP报文 B`并发送给服务端
8. 服务端用`对称密钥`解密`HTTP报文 B`,并将要响应的报文加密之后发送个客户端

### 题外话

Q: 为什么像12306这种政府类的网站需要用户自己手动下载证书，而百度这种不需要手动下载证书？
A: 因为中国没有第三方颁发安全证书的机构，第三方证书都在国外，而中国政府不相信这些机构，所以政府网站需要用户自己手动下载证书
